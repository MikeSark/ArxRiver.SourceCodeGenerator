<h1>ArxRiver - Source Generator</h1>

<h3>Introduction</h3>
Source Generators have been available since .NET 5, which was released in November 2020. Microsoft introduced them as a way to generate code at compile time, providing a powerful tool for improving performance, reducing boilerplate, and enabling new patterns in .NET development.

Source Generators are a feature of the .NET Compiler Platform (Roslyn) that allows you to inspect your program's source code and generate additional source files that are compiled together with the rest of your code. This can be useful for a variety of scenarios, such as generating serialization code, creating dependency injection containers, or implementing the visitor pattern.

> the generated source code can be found in solution explorer under the project that references the package 
>> Dependencies
>>> Analyzers
>>>> ArxRiver.SourceCodeGenerator


### How Source Generators Work
Source Generators are executed by the compiler during the compilation process. When the compiler encounters a Source Generator, it invokes the generator to produce additional source files based on the input code. These generated files are then compiled along with the rest of the code, allowing you to use the generated code in your application.

### Source code generators included in ArxRiver.SourceCodeGenerator assembly.

ArxRiver.SourceGenerator contains the following source code generators:
| Source Code Generator | Description | output class name |
| --- | --- | --- |
| Class Builder Generator | Generates a builder class for a given type. The builder class provides fluent methods for setting the properties of the class and a build method for creating an instance of the class. | {ClassName}Builder |
| Cloneable Class Generator | Generates a clone method for a given type. The clone method creates a deep copy of the object, including all nested objects. | {ClassName} |
| Deconstruct Extension Method Generator | Generates an extension method that deconstructs an object into its properties. The extension method allows you to deconstruct an object using the tuple syntax. | {ClassName}Extensions |
| Logger Builder Generator | Generates a logger builder class for a given type. The logger builder class provides methods for configuring a logger instance and a build method for creating an instance of the logger. | {ClassName}LoggerBuilder |
| Task Manager Generator | Generates a task manger that allows queueing, executing, and returning the result of a task if available in a multi threaded environment  |  partial class TaskManager|
| Fluent Class builder   | Generates a partial class that incorporates fluent pattern| partial class <classname> |


### How to use the source code generators
The source code generators in the assembly rely on attributes from the ArxRiver.SourceCodeGenerator.Attributes assembly. The attributes are used to specify the indicate what type of the source code should be generated.properties and methods that should be generated by the source code generators.


## Class Builder Generator
<details>
<summary>
The Class Builder Generator is a source code generator that creates a class with the specified properties and methods. This generator is useful for generating classes that implement common patterns, such as data transfer objects (DTOs) or entity classes.
</summary>

To utilize the Class Builder Generator, you should annotate your class with the [AutoClassBuilderAttribute] attribute and define the properties and methods you want to include. If there are properties you wish to exclude from the generated code, you can use the [SkipClassBuilderAttributeName] attribute.

```csharp
[AutoClassBuilder]
public class Client
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public string? Email { get; set; }
    public string? PhoneNumber { get; set; }
    public Address? Address { get; set; }
    public Note? Note { get; set; }
    public List<Note>? Notes { get; set; }
}

[AutoClassBuilder]
public class Note
{
    public int Id { get; set; }
    public string? Title { get; set; } = null;
    public string? Content { get; set; } = null;
    public DateTime CreationDate { get; set; } = DateTime.Now;
}

[AutoClassBuilder]
public class Address
{
    public string? Street { get; set; }
    public string? City { get; set; }
    public string? State { get; set; }
    public string? ZipCode { get; set; }
}


The auto generated source cod efor the above class will be as follows:

----------------    Auto generated source code for Person class    ----------------

public class ClientBuilder
{
	
	private readonly Client _instance = new Client();
	private readonly AddressBuilder _addressBuilder = AddressBuilder.Create();
	private readonly NoteBuilder _noteBuilder = NoteBuilder.Create();
	private Func<Client, bool>? _validationRule = null;
	
	private ClientBuilder() {}
	
	public static ClientBuilder Create() => new ClientBuilder();
	
	public ClientBuilder WithValidationRule(Func<Client, bool>? validationRule)
	{
		_validationRule = validationRule;
		return this;
	}
	
	public ClientBuilder WithId(int id)
	{
		_instance.Id = id;
		return this;
	}
	
	public ClientBuilder WithName(string? name)
	{
		_instance.Name = name;
		return this;
	}
	
	public ClientBuilder WithEmail(string? email)
	{
		_instance.Email = email;
		return this;
	}
	
	public ClientBuilder WithPhoneNumber(string? phoneNumber)
	{
		_instance.PhoneNumber = phoneNumber;
		return this;
	}
	
	public ClientBuilder WithAddress(Action<AddressBuilder> addressBuilderAction)
	{
		addressBuilderAction(_addressBuilder);
		return this;
	}
	
	public ClientBuilder WithAddress(ArxRiver.SourceGenerator.XUnitTest.TestModels.ClassBuilder.Address? address)
	{
		_instance.Address = address;
		return this;
	}
	
	public ClientBuilder WithNote(Action<NoteBuilder> noteBuilderAction)
	{
		noteBuilderAction(_noteBuilder);
		return this;
	}
	
	public ClientBuilder WithNote(ArxRiver.SourceGenerator.XUnitTest.TestModels.ClassBuilder.Note? note)
	{
		_instance.Note = note;
		return this;
	}
	
	public ClientBuilder WithNotes(System.Collections.Generic.List<ArxRiver.SourceGenerator.XUnitTest.TestModels.ClassBuilder.Note>? notes)
	{
		_instance.Notes = notes;
		return this;
	}
	
	
	public Client Build(Func<Client, bool>?  validationRule = null)
	{
		_instance.Address = _addressBuilder.Build();
		_instance.Note = _noteBuilder.Build();
		
		_validationRule = validationRule ?? _validationRule;
		if (_validationRule != null && !_validationRule(_instance))
		{
			throw new ArgumentException("Validation failed for Client.");
		}
		return _instance;
	}
	
}


// here is an example of how to use the PersonBuilder class.
var client= ClientBuilder.Create()
            .WithValidationRule(c => c is { Address: not null, Note: not null })
            .WithId(1)
            .WithAddress(a => a
                .WithCity("Burbank")
                .WithStreet("780 GlenOaks Blvd")
                .WithZipCode("54695")
                .WithValidationRule(a => !string.IsNullOrWhiteSpace(a.City) && !string.IsNullOrWhiteSpace(a.Street))
            )
            .WithNote(n => n
                .WithTitle("single Note")
                .WithContent("single note content")
                .WithCreationDate(DateTime.Now)
                .WithId(500)
                .WithValidationRule(n => n.Id > 0 && !string.IsNullOrWhiteSpace(n.Title))
            )
            .WithEmail("")
            .WithPhoneNumber("818-747-6985")
            .WithNotes([
                new Note() { Title = "", Content = "", CreationDate = DateTime.Now, Id = 2500 },
                new Note() { Title = "", Content = "", CreationDate = DateTime.Now, Id = 3000 },
                new Note() { Title = "", Content = "", CreationDate = DateTime.Now, Id = 4500 }
            ])
            .Build();

```	
</details>



## Cloneable Class Generator
<details>
<summary>
The Cloneable Class Generator is a source code generator that creates a partial class with a few cloning methods for a class that has the `[CloneableAttribute]`  . The clone method creates a deep copy of the object, including all nested objects. This generator is useful for generating clone methods for classes that do not implement the ICloneable interface.
</summary>

```csharp

[Cloneable]
public partial class Task      // the cloneable class needs to be a partial class
{
	public Guid? TaskId { get; set; }

	public string? Name { get; set; }

	public int Description { get; set; }

	public DateTime CreatedOn { get; set; }

	public string? EmployeeId { get; set; } = string.Empty;
	
	[clone]
	public Animal Species { get; set; }
}
```

The auto generated source code for the above class will be as follows:

```csharp
public partial class Task
{
	/// <summary>
	/// Creates a simple clone of Task with NO circular reference check.
	/// </summary>
	public Task Clone()
	{
		return new Task
		{
			TaskId = this.TaskId,
			Name = this.Name,
			Description = this.Description,
			EmployeeId = this.EmployeeId,
			Species = this.Species
		};
	}
	
	
	/// <summary>
	/// Creates a simple cone of Task with circular reference check.
	/// </summary>
	public Task SafeClone(Stack<object> referenceChain = null)
	{
		if (referenceChain is not null && referenceChain.Contains(this))
		    return this;
		
		referenceChain ??= new Stack<object>();
		referenceChain.Push(this);
		
		var result = new Task
		{
			TaskId = this.TaskId,
			Name = this.Name,
			Description = this.Description,
			EmployeeId = this.EmployeeId,
			Species = this.Species
		};
		
		referenceChain.Pop();
		return result;
	}
	
	/// <summary>
	/// Creates a simple Deep Clone of Task with NO circular reference check.
	/// 
	/// </summary>
	public Task DeepClone()
	{
		return new Task
		{
			TaskId = this.TaskId,
			Name = this.Name,
			Description = this.Description,
			EmployeeId = this.EmployeeId,
			Species = this.Species?.Clone()
		};
	}
	
	
	/// <summary>
	/// Creates a safe deep clone of Task with circular reference checking.
	/// </summary>
	public Task DeepCloneSafe(Stack<object> referenceChain = null)
	{
		if (referenceChain is not null && referenceChain.Contains(this))
		    return this;
		
		referenceChain ??= new Stack<object>();
		referenceChain.Push(this);
		
		var result = new Task
		{
			TaskId = this.TaskId,
			Name = this.Name,
			Description = this.Description,
			EmployeeId = this.EmployeeId,
			Species = this.Species?.SafeClone(referenceChain)
		};
		
		referenceChain.Pop();
		return result;
	}
}

```
</details>

## Deconstruct Extension Method Generator
<details>
<summary>
The Deconstruct Extension Method Generator is a source code generator that creates an extension method for a class that has the `[DeconstructableAttribute]` attribute. In
addition to the `[DeconstructableAttribute]` attribute, the public properties of the class that should be part of deconstruct need to be flagged with `[IncludeInDeconstructAttributre]`. 
The extension method allows you to deconstruct an object into its properties using the tuple syntax. 
</summary>


```csharp
[AutoClassBuilder]
public class Person
{

    [IncludeInDeconstruct]
    public string? FirstName { get; set; }

    [IncludeInDeconstruct]
    public string? LastName { get; set; }

    
    public int Age { get; set; }
}
```

The auto generated source code for the above class will be as follows;

```csharp	
public static class PersonExtensions
{
	public static void Deconstruct(this Person person, out string? firstName, out string? lastName)
	{
		firstName = person.FirstName;
		lastName = person.LastName;
	}
}
```
</details>

## Logger Builder Generator
<details>
<sumamry>
The Logger Builder Generator is a source code generator that creates one of the 4 logger builder classes mentioned below if there is a class that has corresponding attribute
| Logger Type | Attribute | output class name |
| --- | --- | --- |
| Console Logger | `[ConsoleLoggerAttribute]` | {ClassName}ConsoleLoggerBuilder |
| Colored Console Logger | `[ColoredConsoleLoggerAttribute]` | {ClassName}ColoredConsoleLoggerBuilder |
| File Logger | `[FileLoggerAttribute]` | {ClassName}FileLoggerBuilder |
| Json File Logger | `[JsonFileLoggerAttribute]` | {ClassName}JsonFileLoggerBuilder |

</summary>

The logger builder class provides methods for configuring a logger instance and a build method for creating an instance of the logger. The logger builder class can be used to configure the logger instance with the desired settings, such as log level, log format, and log file path.

** Logger class definition **
```csharp
[PsLogger(PsLoggerAttribute.LoggerType.Json)]
public partial class JsonLogger { }

Auto generated logger will look like this,
public sealed class JsonLoggerBuilder
{
	
	private const string FileTargetName = "jsonFiletarget";
	
	private Logger? _logger;
	private LoggingConfiguration? _loggingConfiguration;
	
	private string _applicationName = AppDomain.CurrentDomain.FriendlyName;
	private LogLevel _minimumLogLevel = LogLevel.Info;
	private LogLevel _maximumLogLevel = LogLevel.Fatal;
	private string _logFileName = string.Empty;
	private bool _concurrentWrites = true;
	private bool _keepFileOpen = false;
	private string _archiveLogFileName = string.Empty;
	private long _archiveAboveSize = 1024 * 1024;
	private int _maxArchiveFiles = 10;
	private ArchiveNumberingMode _archiveNumbering = ArchiveNumberingMode.Rolling;
	private FileArchivePeriod _archiveEvery = FileArchivePeriod.Day;
	private string _archiveDateFormat = "yyyyMMdd";
	private bool _enableArchiveFileCompression = true;
	private bool _archiveOldFileOnStartup = true;
	
	private readonly FileTarget _fileTarget;
	private  readonly IList<JsonAttribute> _defaultJsonAttributes = new List<JsonAttribute>()
	{
	    new JsonAttribute("timestamp", "${longdate}"),
	    new JsonAttribute("level", "${level}"),
	    new JsonAttribute("logger", "${logger}"),
	    new JsonAttribute("message", "${message}"),
	    new JsonAttribute("exception", "${exception:format=ToString}"),
	    new JsonAttribute("applicationName", "${gdc:item=ApplicationName}")
	};
	
	public JsonLoggerBuilder()
	{
	
	_fileTarget = new FileTarget(FileTargetName);

var jsonLayout = new JsonLayout();
foreach (var defaultJsonAttribute in _defaultJsonAttributes)
{
    jsonLayout.Attributes.Add(defaultJsonAttribute);
}

_fileTarget.Layout = jsonLayout;

	}
	
	public JsonLoggerBuilder WithApplicationName(string applicationName)
	{
	    _applicationName = applicationName;
	    return this;
	}
	
	public JsonLoggerBuilder WithMinimumLogLevel(LogLevel minimumLogLevel)
	{
	    _minimumLogLevel = minimumLogLevel;
	    return this;
	}
	
	public JsonLoggerBuilder WithMaximumLogLevel(LogLevel maximumLogLevel)
	{
	    _maximumLogLevel = maximumLogLevel;
	    return this;
	}
	
	public JsonLoggerBuilder WithLogFileName(string logFileName)
	{
	    _logFileName = logFileName;
	    return this;
	}
	
	public JsonLoggerBuilder WithConcurrentWrites(bool concurrentWrites)
	{
	    _concurrentWrites = concurrentWrites;
	    return this;
	}
	
	public JsonLoggerBuilder WithKeepFileOpen(bool keepFileOpen)
	{
	    _keepFileOpen = keepFileOpen;
	    return this;
	}
	
	public JsonLoggerBuilder WithArchiveLogFileName(string archiveLogFileName)
	{
	    _archiveLogFileName = archiveLogFileName;
	    return this;
	}
	
	public JsonLoggerBuilder WithArchiveAboveSize(long archiveAboveSize)
	{
	    _archiveAboveSize = archiveAboveSize;
	    return this;
	}
	
	public JsonLoggerBuilder WithMaxArchiveFiles(int maxArchiveFiles)
	{
	    _maxArchiveFiles = maxArchiveFiles;
	    return this;
	}
	
	public JsonLoggerBuilder WithArchiveNumbering(ArchiveNumberingMode archiveNumbering)
	{
	    _archiveNumbering = archiveNumbering;
	    return this;
	}
	
	public JsonLoggerBuilder WithArchiveEvery(FileArchivePeriod archiveEvery)
	{
	    _archiveEvery = archiveEvery;
	    return this;
	}
	
	public JsonLoggerBuilder WithArchiveDateFormat(string archiveDateFormat)
	{
	    _archiveDateFormat = archiveDateFormat;
	    return this;
	}
	
	public JsonLoggerBuilder WithEnableArchiveFileCompression(bool enableArchiveFileCompression)
	{
	    _enableArchiveFileCompression = enableArchiveFileCompression;
	    return this;
	}
	
	public JsonLoggerBuilder WithArchiveOldFileOnStartup(bool archiveOldFileOnStartup)
	{
	    _archiveOldFileOnStartup = archiveOldFileOnStartup;
	    return this;
	}
	
	public JsonLoggerBuilder WithJsonFileLayout(IList<JsonAttribute> jsonAttributes)
	{
	    var jsonLayout = new JsonLayout();
	    foreach (var jsonAttribute in jsonAttributes)
	    {
	        jsonLayout.Attributes.Add(jsonAttribute);
	    }
	
	    _fileTarget.Layout = jsonLayout;
	    return this;
	}
	
	public Logger Build()
	{
	    LogManager.ThrowConfigExceptions = true;
	    NLog.GlobalDiagnosticsContext.Set("ApplicationName", "PS LOG");
	
	    _loggingConfiguration = new LoggingConfiguration();
	    
	    _fileTarget.FileName = _logFileName;
	    _fileTarget.ConcurrentWrites = _concurrentWrites;
	    _fileTarget.KeepFileOpen = _keepFileOpen;
	    _fileTarget.ArchiveFileName = _archiveLogFileName;
	    _fileTarget.ArchiveAboveSize = _archiveAboveSize;
	    _fileTarget.MaxArchiveFiles = _maxArchiveFiles;
	    _fileTarget.ArchiveNumbering = _archiveNumbering;
	    _fileTarget.ArchiveEvery = _archiveEvery;
	    _fileTarget.ArchiveDateFormat = _archiveDateFormat;
	    _fileTarget.EnableArchiveFileCompression = _enableArchiveFileCompression;
	    _fileTarget.ArchiveOldFileOnStartup = _archiveOldFileOnStartup;
	
	    _loggingConfiguration.AddTarget(_applicationName, _fileTarget);
	    _loggingConfiguration.LoggingRules.Add(new("*", _minimumLogLevel, _maximumLogLevel, _fileTarget));
	    
	    LogManager.Configuration = _loggingConfiguration;
	
	    _logger = LogManager.GetLogger(_applicationName);
	    return _logger;
	}
	
	
}
```

So the JsonLoggerBuilder can be used as follows,

```csharp
var jsonLogBuilder = new JsonLoggerBuilder()
    .WithApplicationName("My Application")
    .WithLogFileName("c:/temp/mylog.txt")
    .WithConcurrentWrites(true);


var jsonLogger = jsonLogBuilder.Build();
jsonLogger.Info("Json Info Logged");
jsonLogger.Warn("Json Info Logged");
jsonLogger.Debug("Json Info Logged");
jsonLogger.Error("Json Info Logged");

```

</details>

## Task Manager Generator
<details>
<summary>
In order for the generator to create a class, we need to define a partial class with a name we want the manager o be created. The Source generator will detect the class by verifying that the class has the AutoTaskManager attribute and generate the proper class for it.
</summary>


```csharp
[AutoTaskManager]
public partial class TaskManager {}

The auto generated Task manager can be found in the analyzer section of dependencies.
it will look like,
public partial class TaskManager
{
	
	private const int PercentageOfMachineCpu = 60;// 60% of available CPUs
	private readonly ConcurrentQueue<ITaskInfo> _taskQueue = new ConcurrentQueue<ITaskInfo>();
	private readonly ConcurrentBag<Task> _allTasks = new ConcurrentBag<Task>();
	private readonly SemaphoreSlim _semaphore;
	
	public event Action<int, int> TasksRemainingChanged;
	
	public TaskManager()
	{
		var maxDegreeOfParallelism = (int)((Environment.ProcessorCount * PercentageOfMachineCpu) / 100); // 60% of available CPUs
		
		if (maxDegreeOfParallelism <= 0)
		    throw new ArgumentOutOfRangeException(nameof(maxDegreeOfParallelism), "Must be greater than zero.");
		
		_semaphore = new SemaphoreSlim(maxDegreeOfParallelism, maxDegreeOfParallelism);
	}
	
	/// <summary>
	/// Enqueues a task that returns a result with an optional callback.
	/// </summary>
	/// <typeparam name="T">The type of the result.</typeparam>
	/// <param name="taskFunction">The asynchronous task function to execute.</param>
	/// <param name="callback">Optional callback to invoke upon task completion or fault.</param>
	public void EnqueueTask<T>(Func<Task<T>> taskFunction, Action<T, Exception?> callback = null)
	{
	    if (taskFunction == null)
	        throw new ArgumentNullException(nameof(taskFunction));
	
	    var taskInfo = new TaskInfo<T>(taskFunction, callback);
	    _taskQueue.Enqueue(taskInfo);
	    _allTasks.Add(taskInfo.Task);
	
	    TasksRemainingChanged?.Invoke(_taskQueue.Count, _allTasks.Count);
	
	    _ = ProcessQueueAsync();
	}
	
	/// <summary>
	/// Enqueues a task that does not return a result with an optional callback.
	/// </summary>
	/// <param name="taskFunc">The asynchronous task function to execute.</param>
	/// <param name="callback">Optional callback to invoke upon task completion or fault.</param>
	public void EnqueueTask(Func<Task> taskFunc, Action<Exception?> callback = null)
	{
	    if (taskFunc == null)
	        throw new ArgumentNullException(nameof(taskFunc));
	
	    var taskInfo = new TaskInfoVoid(taskFunc, callback);
	    _taskQueue.Enqueue(taskInfo);
	    _allTasks.Add(taskInfo.Task);
	
	    TasksRemainingChanged?.Invoke(_taskQueue.Count, _allTasks.Count);
	
	    // Start processing tasks if possible
	    _ = ProcessQueueAsync();
	}
	
	/// <summary>
	/// Asynchronously waits for all queued and running tasks to complete.
	///
	/// IMPORTANT: We can improve this method to call an optional call back to removed completed tasks.
	///            This will help to keep the memory usage low.
	/// </summary>
	/// <returns>A Task representing the asynchronous wait operation.</returns>
	public async Task WaitAllTasksAsync()
	{
	    Task[] tasksToWait;
	
	    // capture a snapshot of all tasks
	    lock (_allTasks)
	    {
	        tasksToWait = _allTasks.ToArray();
	    }
	
	    await Task.WhenAll(tasksToWait).ConfigureAwait(false);
	}
	
	/// <summary>
	/// Gets the number of tasks remaining in the queue.
	/// </summary>
	public int TasksRemaining => _taskQueue.Count;
	
	/// <summary>
	/// Clears all queued tasks. Note that running tasks will continue to completion.
	/// </summary>
	public void ClearQueuedTasks()
	{
	    while (_taskQueue.TryDequeue(out _)) { }
	
	    TasksRemainingChanged?.Invoke(_taskQueue.Count, _allTasks.Count);
	}
	
	
	/// <summary>
	/// Asynchronously processes tasks in the queue.
	/// </summary>
	private async Task ProcessQueueAsync()
	{
	    while (true)
	    {
	        if (!_taskQueue.TryDequeue(out ITaskInfo taskInfo))
	        {
	            break; // No more tasks to process
	        }
	
	        TasksRemainingChanged?.Invoke(_taskQueue.Count, _allTasks.Count);
	
	        await _semaphore.WaitAsync().ConfigureAwait(false);
	        var executionTask = ExecuteTaskAsync(taskInfo);
	
	        // Detach the task to allow it to run independently
	        _ = executionTask;
	    }
	}
	
	/// <summary>
	/// Executes a single task and handles semaphore release.
	/// </summary>
	/// <param name="taskInfo">The task information to execute.</param>
	private async Task ExecuteTaskAsync(ITaskInfo taskInfo)
	{
	    try
	    {
	        await taskInfo.ExecuteAsync().ConfigureAwait(false);
	    }
	    finally
	    {
	        _semaphore.Release();
	    }
	}
	
	
	private interface ITaskInfo
	{
	    Task ExecuteAsync();
	}
	
	
	/// <summary>
	/// Generic class to hold task information for tasks with return values
	/// </summary>
	/// <typeparam name="T"></typeparam>
	private class TaskInfo<T>(Func<Task<T>> taskFunc, Action<T, Exception?> callback) : ITaskInfo
	{
	    private readonly TaskCompletionSource<T> _tcs = new(TaskCreationOptions.RunContinuationsAsynchronously);
	
	    public Task<T> Task => _tcs.Task;
	
	    public async Task ExecuteAsync()
	    {
	        try
	        {
	            T result = await taskFunc().ConfigureAwait(false);
	            _tcs.SetResult(result);
	            callback?.Invoke(result, null);
	        }
	        catch (Exception? ex)
	        {
	            _tcs.SetException(ex);
	            callback?.Invoke(default(T), ex);
	        }
	    }
	}
	
	/// <summary>
	/// Class to hold task information for tasks without return values
	/// </summary>
	private class TaskInfoVoid(Func<Task> taskFunc, Action<Exception?> callback) : ITaskInfo
	{
	    private readonly TaskCompletionSource<object?> _tcs = new(TaskCreationOptions.RunContinuationsAsynchronously);
	
	    public Task Task => _tcs.Task;
	
	    public async Task ExecuteAsync()
	    {
	        try
	        {
	            await taskFunc().ConfigureAwait(false);
	
	            _tcs.SetResult(null);
	            callback?.Invoke(null);
	        }
	        catch (Exception ex)
	        {
	            _tcs.SetException(ex);
	            callback?.Invoke(ex);
	        }
	    }
	}
	
}

This will allow the dev to add tasks to the manager and receive the response after the execution is complete.

var taskManager = new TaskManager();
        var resultContent = "";
        var exceptionMessage = "";
        var queueCount = 0;
        var tasksCount = 0;

        taskManager.TasksRemainingChanged += (i, i1) =>
            {
                queueCount = i;
                tasksCount = i1;
            };
        
        taskManager.EnqueueTask<string>(async () =>
            {
                await Task.Delay(2000);
                return "Hello";
            }, (result, exception) =>
            {
                resultContent = result;
                exceptionMessage = exception?.Message;
            });        
			        
        await taskManager.WaitAllTasksAsync();

```
</details>

** See the Test project placed in the same solution folder for more samples. **


## Fluent Class Builder
<details>
<summary>
The Fluent class generator creates a partial class based on the annotated partial class. It adds a series of methods that start with Withxxxxx and allow you to assign values to the properties of the class in a method chaining fashion. To validate the instance of the class, a Validate() method is provided that executes a validation rule passed to the object during the creation process.
</summary>

```csharp
[FluentClass]
public partial class JsonLog
{
    public string? Source { get; set; }
    public Guid CorrelationId { get; set; }
    public string Message { get; set; } = string.Empty;
    
    [SkipFluentClass]
    public bool SkippedProperty { get; set; }
}

Source code generator output teh following
public partial class JsonLog
{
	
	private readonly Func<JsonLog, bool>? _validationRule;
	
	public JsonLog() {}
	
	public JsonLog(Func<JsonLog, bool>? validationRule = null)
	{
		_validationRule = validationRule;
	}
	
	public JsonLog WithSource(string? source)
	{
		Source = source;
		return this;
	}
	
	public JsonLog WithCorrelationId(System.Guid correlationId)
	{
		CorrelationId = correlationId;
		return this;
	}
	
	public JsonLog WithMessage(string message)
	{
		Message = message;
		return this;
	}
	
	
	public bool Validate()
	{
		return _validationRule?.Invoke(this) ?? true;
	}
	
}

This will allow the dev to create an object and validate it state. below is an example 


var jsonLogInstance = new JsonLog()
	.WithSource("PS.Common>AuthooLink")
	.WithCorrelationId( Guid.NewGuid())
	.WithMessage("Error");

```
</details>





